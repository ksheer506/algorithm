/* ----------------- 조합 ----------------- */

/**
 * 재귀를 이용한 방법(ex. R = 2)
 * [1,2] [1,3] [1,4] [1,5] ...
 *       [2,3] [2,4] [2,5] ...
 *             [3,4] [3,5] ...
 *                   [4,5] ...
 * R = 각 원소의 길이 = 재귀 depth
 * arr[i] = i+1번째 재귀 depth에서 선택된 값 
 * 
 * 1. 원본 배열에서 원소를 하나씩 꺼내 배열 생성 
 * [1] [2] [3] ...
 * 
 * 2. 순서가 존재하지 않으므로 [1,2,3]와 [1,3,2]는 중복 케이스이다. 즉, 원소의 마지막에 담긴 값의 인덱스가 `index`일 때 다음 재귀 depth에서는 `index + 1`인 원소부터 담아야 한다.
 * 단계 1에서 만든 각 원소들에 대해 cursor+1 ~ N-1까지의 값을 덧붙인다.
 * [1,2] [1,3] [1,4] ...
 * [2,3] [2,4] [2,5] ...
 * [3,4] [3,5] [3,6] ...
 * 
 * 3. 단계 2에서 만든 각 원소들에 대해 cursor+1 ~ N-1까지의 값을 덧붙인다. 
 * [1,2,3] [1,2,4] [1,2,5] ...
 * [1,3,4] [1,3,5] [1,3,6] ...
 * [1,4,5] [1,4,6] [1,4,7] ...
 * ...
 * [2,3,4] [2,3,5] [2,3,6] ...
 * [2,4,5] [2,4,6] [2,4,7] ...
 * ...
 * 
 */
function combination(arr, R) {
 const res = []
 
 const fn = (data, cursor = 0) => {
  if (data.length === R) {
   res.push(data)
   return
  }
  for (let i = cursor; i < arr.length; i++) {
   fn([...data, arr[i]], i + 1)
  }
 }
 fn([])
 
 return res
}



/* ----------------- 순열 ----------------- */